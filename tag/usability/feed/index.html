<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>Usability &#8211; openSUSE Lizards</title>
	<atom:link href="https://lizards.opensuse.org/tag/usability/feed/" rel="self" type="application/rss+xml" />
	<link>https://lizards.opensuse.org</link>
	<description>Blogs and Ramblings of the openSUSE Members</description>
	<lastBuildDate>Fri, 06 Mar 2020 11:29:40 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>

	<item>
		<title>Adventures with Intel Atom D510 board</title>
		<link>https://lizards.opensuse.org/2010/10/08/adventures-with-intel-atom-d510-board/</link>
		<pubDate>Fri, 08 Oct 2010 15:55:31 +0000</pubDate>
		<dc:creator><![CDATA[Togan Muftuoglu]]></dc:creator>
				<category><![CDATA[Usability]]></category>
		<category><![CDATA[X.org]]></category>
		<category><![CDATA[openSUSE]]></category>
		<category><![CDATA[susestudio]]></category>

		<guid isPermaLink="false">http://lizards.opensuse.org/?p=5399</guid>
		<description><![CDATA[For long I had been using my old laptop for everything; building images with KIWI, wrtiting documents using LaTeX and Docbook XML, sorting my photos with Digikam. However, for some odd reason I wanted to have something new. Dangerous word, new is.
I have 2 Intel Atom's running for my mail and web servers and I was quite happy with their performances, (by the way I am still happy). Hence I decided to ride the change train and bought the Intel D510 board]]></description>
				<content:encoded><![CDATA[<p>For long I had been using my old laptop for everything; building images with KIWI, writing documents using LaTeX and Docbook XML, sorting my photos with Digikam. I have been upgrading since version 9.0 and at the moment opensuse 11.1 was the release ( OK with lots of new software thanks to the Build server. However, for some odd reason I wanted to have something new. Dangerous word, new is.</p>
<p>I have 2 Intel Atom&#8217;s running for my mail and web servers and I was quite happy with their performances, (by the way I am still happy). Hence I decided to ride the change train and bought the Intel D510 board</p>
<p>opensuse 11.3 Kde LiveCd worked fine and using Susestudio I designed my image. So far was really good. Booting the usb brought my feet back to earth. A frozen screen. So I tried the failsafe option and I had a 800X600 display. Reboot and this time trying &#8220;nomodeset&#8221; option same thing. Nevertheless I decided to give it a go ( I can always use it at run level 3).</p>
<p>Last night I have decided to include the Kernel:HEAD repo so I am using kernel-default-2.6.36-rc6.25.1.x86_64 along with the X11:XOrg repos using X.Org 1.9.0.901 (1.9.1 RC 1) so now I have &#8220;1366&#215;768 (the max my monitor can give) and I do not need to set &#8220;nomodeset&#8221; in the boot options anymore.</p>
<p>I have not tweaked everything yet, like my Logitech keyboard&#8217;s multimedia keys are useless in KDE at the moment.Â  At the end they will work one way or the other, I am sure.</p>
<p>Lesson Learned: do your homework well before jumping the change train or enjoy the adventures</p>
]]></content:encoded>
			</item>
		<item>
		<title>Usability Symposium</title>
		<link>https://lizards.opensuse.org/2009/11/27/usability-symposium/</link>
		<comments>https://lizards.opensuse.org/2009/11/27/usability-symposium/#comments</comments>
		<pubDate>Fri, 27 Nov 2009 15:33:13 +0000</pubDate>
		<dc:creator><![CDATA[Klaas Freitag]]></dc:creator>
				<category><![CDATA[Boosters]]></category>
		<category><![CDATA[Desktop]]></category>
		<category><![CDATA[Events]]></category>
		<category><![CDATA[GNOME]]></category>
		<category><![CDATA[KDE]]></category>
		<category><![CDATA[Presentation]]></category>
		<category><![CDATA[Usability]]></category>

		<guid isPermaLink="false">http://lizards.opensuse.org/?p=2681</guid>
		<description><![CDATA[On wednesday Will and me visited the Usability Symposium 2009 of the Network for User Oriented Software Design, a group which consists mainly of people from the Georg Simon Ohm University of Applied Sciences here in Nuernberg and people from local companies such as Astrum. It was the first symposium of this group and they [&#8230;]]]></description>
				<content:encoded><![CDATA[<p>On wednesday Will and me visited the <a href="http://www.astrum-it.de/desktopdefault.aspx/tabid-23/173_read-1476/">Usability Symposium 2009</a> of the Network for User Oriented Software Design, a group which consists mainly of people from the <a href="http://www.ohm-hochschule.de/index.php?id=319&amp;L=1">Georg Simon Ohm University of Applied Sciences</a> here in Nuernberg and people from local companies such as <a href="http://www.astrum-it.de/">Astrum</a>. It was the first symposium of this group and they gave three presentations about software usability. </p>
<p>One of the presentations were given by Evamaria Fuchs and Dr. Sigi Olschner, both former SUSE employees who worked in the usability lab. They presented about the development of the <a href="http://home.kde.org/~binner/kickoff/sneak_preview.html">KDE KickOff menu</a> that we shipped in version 10-something for KDE 3. Its successor became the KDE 4 default menu. Eva and Sigi presented how consequent usability work which goes along with the development effort can improve the quality measurable. They also gave a very good insight on free software and open source development in general, taking into account that most people from the audience did not have any experience with it. It was a very nice talk.</p>
<p>While Will was presenting KDE 4 to some interested people Sigi gave me some lessons on how to set up and use the eye tracking device that we have in the Boosters team now. We certainly need another lesson and much more knowledge about usability in general but that was a good start &#8211; thank you Sigi <img src="https://s.w.org/images/core/emoji/2.2.1/72x72/1f642.png" alt="&#x1f642;" class="wp-smiley" style="height: 1em; max-height: 1em;" /> </p>
<p>Usability experts out there &#8211; our Eye Tracker is ready to be used by you for the good of free software! I am wondering when we will have the first session where we try to examine user experience of our software with that device.</p>
]]></content:encoded>
			<wfw:commentRss>https://lizards.opensuse.org/2009/11/27/usability-symposium/feed/</wfw:commentRss>
		<slash:comments>3</slash:comments>
		</item>
		<item>
		<title>Button Order in YaST: Trying to Make Peace with Both Worlds</title>
		<link>https://lizards.opensuse.org/2008/08/28/button-order-in-yast-trying-to-make-peace-with-both-worlds/</link>
		<comments>https://lizards.opensuse.org/2008/08/28/button-order-in-yast-trying-to-make-peace-with-both-worlds/#comments</comments>
		<pubDate>Thu, 28 Aug 2008 15:23:25 +0000</pubDate>
		<dc:creator><![CDATA[Stefan Hundhammer]]></dc:creator>
				<category><![CDATA[GNOME]]></category>
		<category><![CDATA[KDE]]></category>
		<category><![CDATA[Systems Management]]></category>
		<category><![CDATA[Usability]]></category>
		<category><![CDATA[YaST]]></category>
		<category><![CDATA[button order]]></category>

		<guid isPermaLink="false">http://lizards.opensuse.org/?p=145</guid>
		<description><![CDATA[KDE and GNOME have different button orders. Like many desktop-related issues, this has been a subject of heated debates time and time again. Where KDE uses something like this: GNOME would use something like this: Which one is right? Which one is wrong? There is no real answer to that; it will always be more [&#8230;]]]></description>
				<content:encoded><![CDATA[<p>KDE and GNOME have different button orders. Like many desktop-related issues, this has been a subject of heated debates time and time again.</p>
<p>Where KDE uses something like this:</p>
<p><img src="http://files.opensuse.org/opensuse/en/e/e5/Kde-ok-cancel.png" /></p>
<p><img src="http://files.opensuse.org/opensuse/en/0/0c/Kde-continue-cancel.png" /></p>
<p><img src="http://files.opensuse.org/opensuse/en/2/28/Kde-ok-apply-cancel-help.png" /></p>
<p>GNOME would use something like this:</p>
<p><img src="http://files.opensuse.org/opensuse/en/c/cc/Gnome-ok-cancel.png" /></p>
<p><img src="http://files.opensuse.org/opensuse/en/d/dc/Gnome-continue-cancel.png" /></p>
<p><img src="http://files.opensuse.org/opensuse/en/8/82/Gnome-ok-apply-cancel-help.png" /></p>
<p>Which one is right? Which one is wrong? There is no real answer to that; it will always be more a religious debate rather than an objective discussion. </p>
<p><strong>YaST Button Order</strong></p>
<p>So, which button order to choose for YaST?</p>
<p>For historical reasons, we used the KDE button order. But this has repeatedly started the same heated discussions as for KDE vs. GNOME, with the same results &#8212; which is, no tangible result, only something along the lines of &#8220;because we says so&#8221; (and didn&#8217;t you always hate it as a kid when mom or dad said that?).</p>
<p>YaST should not favour one of the major desktops over another. YaST should work well for all users. So, YaST should adapt to the environment it runs in.</p>
<p>YaST comes in different flavours. There is the graphical version: The YaST Qt UI (user interface) engine (Side note: The YaST Qt UI is not in any way KDE specific; Qt just happens to be a great toolkit for making graphical user interfaces, and KDE happens to use it, too. There is not one single line of KDE-specific code in the YaST Qt UI.). </p>
<p>There is also the text-based version, the YaST NCurses UI.</p>
<p>As an alternative graphical UI, there is also the YaST Gtk UI which uses the same widget toolkit (Gtk) as GNOME. That brings YaST closer to the GNOME crowd.  At least, that&#8217;s the theory. Yet, that alone didn&#8217;t improve the situation in any way for this button order issue:</p>
<p>YaST dialogs are specified in a subset of the YaST-specific YCP scripting language. Those dialog descriptions include input fields, list boxes, headings, etc. as well as the logical arrangement of all those user interface elements (<em>widgets</em>, even though that term has seen a lot of misuse recently). And buttons, too, of course.</p>
<p>So, the arrangement of buttons was still fixed. The YaST Gtk UI couldn&#8217;t really do anything about changing that button order so it looked more GNOMEish.</p>
<p>This is now different. We introduced a new widget <em>ButtonBox</em> that abstracts exactly that. A YaST module developer now only specifies &#8220;there is a ButtonBox, this is where I put my buttons, and the ButtonBox will arrange them as appropriate&#8221;.</p>
<p><strong>&#8230;for users&#8230;</strong></p>
<p>So now it is possible for the first time to use the proper button order for each environment: GNOME button order for the Gtk UI, KDE button order for the Qt UI.</p>
<p>But there is more.</p>
<p><strong>&#8230;for power users&#8230;</strong></p>
<p>The Qt UI can now demonstrate the fact that it&#8217;s not KDE specific. It checks what environment it runs in and uses the appropriate button order: GNOME button order when running in GNOME and KDE button order for KDE (or other window managers).</p>
<p>It checks the $DESKTOP_SESSION and $WINDOWMANAGER environment variables to figure that out. But of course power users can still override that and set the $Y2_BUTTON_ORDER environment variable to &#8220;KDE&#8221; or &#8220;GNOME&#8221;.</p>
<p><strong>&#8230;for YaST developers&#8230;</strong></p>
<p>Of course, such a change doesn&#8217;t come over night. There is a very large amount of YaST code. I counted 69 .desktop files in my /usr/share/applications/YaST2 directory; that corresponds to 69 YaST modules. On my machine I have 432000+ lines of YCP code below /usr/share/YaST2 . Now try to figure out how many YaST dialogs that might be, and how many of them need to be converted to use that new <em>ButtonBox</em> mechanism.</p>
<p>Obviously, it&#8217;s a lot of stuff to change. So the change should not hurt the people doing the change more than it absolutely has to. Don&#8217;t forget, it&#8217;s not just working hours that have to be paid; it&#8217;s also working hours that can&#8217;t be spent on implementing other features or on fixing bugs. And any change (even more so changing code at so many places) means a possibility to introduce new bugs.</p>
<p><strong>&#8230;trying to be smart&#8230;</strong></p>
<p>So this <em>ButtonBox</em> mechanism was made to be smart, to re-use existing information (things that are already there in the code), to make good use of existing conventions.</p>
<p>In principle, using something like the <em>ButtonBox</em> means having to tell it which logical role each button has so it can be arranged according to the current button order&#8217;s conventions: Which button is the positive confirmation of a dialog (it might be &#8220;OK&#8221; or &#8220;Continue&#8221; or &#8220;Yes&#8221;, but it might also be someting like &#8220;Save&#8221; or &#8220;Print&#8221;), which one is the &#8220;safe escape&#8221; (&#8220;Cancel&#8221;, but sometimes also &#8220;No&#8221;), which one is the &#8220;Apply&#8221; button or the &#8220;Help&#8221; button, and which ones are just &#8220;other&#8221; buttons. Remember, YaST is being translated into some dozen languages, so just hard-coding the English button labels won&#8217;t do.</p>
<p>But we already have a mechanism that maps (translated!) button labels to function keys, and that mechanism does something similar: There is a list of commonly used button labels and what function key is to be used (in the NCurses UI) for them. For example, &#8220;OK&#8221;, &#8220;Continue&#8221;, &#8220;Yes&#8221;, &#8220;Next&#8221; all map to the F10 key, &#8220;Cancel&#8221; to F9, &#8220;Help&#8221; to F1.</p>
<p>Extending that thought some more, it makes sense to assume an &#8220;okButton&#8221; role for buttons that are otherwise assigned the F10 key, &#8220;cancelButton&#8221; for buttons that get the F9 key, etc.</p>
<p>Buttons in YCP each are assigned a widget ID. That ID is the &#8220;handle&#8221; by which a button is being referenced; this is what the YCP application receives when it is informed that the user clicked that key. When specifiying a layout with buttons, this looks (slightly simplified) like this:</p>
<pre>
UI::OpenDialog( 
    `VBox(
         `InputField(`id(`name  ), "Name" ),
         `InputField(`id(`street), "Street" ),
         ...
         `HBox(
               `PushButton(`id(`ok    ), "OK" ),
               `PushButton(`id(`apply ), "Apply" ),
               `PushButton(`id(`cancel), "Cancel" )
               )
         )
);
</pre>
<p>As shown in this example, a button with the &#8220;OK&#8221; role typically has an ID like `id(`ok), a &#8220;Cancel&#8221; button has `id(`cancel), an &#8220;Apply&#8221; button has `id(`apply). So this information is used, too, to figure out what role a button has.</p>
<p>Of course, there are still situations where the system needs to be explicitly told what button has which role: It&#8217;s hard to figure out in a generic way that a &#8220;Print&#8221; button or a &#8220;Save&#8221; button has the &#8220;okButton&#8221; role in a dialog. In that case, the YCP developer has to change the code to look like this:</p>
<p><code>`PushButton(`id(`print), `opt(`okButton), "Print" )</code></p>
<p><strong>&#8230;the normal case&#8230;</strong></p>
<p>But in many cases, the migration is as simple as replacing the `HBox() (the horizontal layout box) holding the buttons with `ButtonBox():</p>
<pre>
UI::OpenDialog( 
    `VBox(
         `InputField(`id(`name  ), "Name" ),
         `InputField(`id(`street), "Street" ),
         ...
         `ButtonBox(        // This is the only line that changed
               `PushButton(`id(`ok    ), "OK" ),
               `PushButton(`id(`apply ), "Apply" ),
               `PushButton(`id(`cancel), "Cancel" )
               )
         )
);
</pre>
<p><strong>&#8230;taming the masses&#8230;</strong></p>
<p>Just imagine doing only this little change in 432000+ lines of code &#8211; of course, only where such a `HBox() contains `PushButtons, not just blindly replacing all `HBoxes. And just changing it is not all there is to it; each dialog has to be tested, too. And that alone is not so trivial: A dialog might easily only be shown in very exotic cases, so the developers doing the test have to recreate each of those exotic cases just to see the dialog.</p>
<p>You see, masses of code are a dimension of complexity all of their own. Little things that look trivial to do gain a whole new meaning. Everybody can do this change in one or two places, but try to do it in someting as big as YaST &#8212; without introducing new bugs that would wreck other people&#8217;s system.</p>
<p>Yet, we do those kinds of changes, typically unnoticed by the user community. And those little things are what, if added up, make or break a system&#8217;s quality.</p>
<p>We don&#8217;t take such decisions lightly. But we felt that in this specific case (the button order) the gain would be worth the pain: Users should feel at home in the tools we provide. And having the buttons where you are used to is part of this feeling at home.</p>
<p><strong>Further Reading</strong></p>
<p><a href="http://en.opensuse.org/YaST/Development/Misc/Button_Order">http://en.opensuse.org/YaST/Development/Misc/Button_Order</a></p>
]]></content:encoded>
			<wfw:commentRss>https://lizards.opensuse.org/2008/08/28/button-order-in-yast-trying-to-make-peace-with-both-worlds/feed/</wfw:commentRss>
		<slash:comments>3</slash:comments>
		</item>
		<item>
		<title>Making openSUSE 11.0 LiveUSB : The Easiest (and Fastest) Way</title>
		<link>https://lizards.opensuse.org/2008/05/31/making-opensuse-110-liveusb-the-easiest-and-fastest-way/</link>
		<comments>https://lizards.opensuse.org/2008/05/31/making-opensuse-110-liveusb-the-easiest-and-fastest-way/#comments</comments>
		<pubDate>Sat, 31 May 2008 05:12:11 +0000</pubDate>
		<dc:creator><![CDATA[Masim "Vavai" Sugianto]]></dc:creator>
				<category><![CDATA[Documentation]]></category>
		<category><![CDATA[Usability]]></category>
		<category><![CDATA[LiveUSB]]></category>
		<category><![CDATA[openSUSE-ID]]></category>

		<guid isPermaLink="false">http://lizards.opensuse.org/?p=38</guid>
		<description><![CDATA[In earlier post, I&#8217;m writing &#8220;How to build openSUSE LiveUSB with Kiwi&#8221; tutorial guide and thinking how to get same results with more easier tips. Another distro came with easy trick to make a bootable LiveUSB and I think openSUSE should be ðŸ˜‰ . Kiwi is a great tools for making openSUSE liveUSB, QEMU Image, [&#8230;]]]></description>
				<content:encoded><![CDATA[<p><a href="http://www.vavai.com/blog/uploads/liveusb-2.png"><img src="http://www.vavai.com/blog/uploads/liveusb-1.jpg" alt="LiveUSB desktop" width="500" height="333" /></a></p>
<p>In earlier post, I&#8217;m writing &#8220;<a href="http://lizards.opensuse.org/2008/05/21/opensuse-liveusb-with-kiwi/">How to build openSUSE LiveUSB with Kiwi</a>&#8221; tutorial guide and thinking how to get same results with more easier tips.  Another distro came with easy trick to make a bootable LiveUSB and I think openSUSE should be <img src="https://s.w.org/images/core/emoji/2.2.1/72x72/1f609.png" alt="&#x1f609;" class="wp-smiley" style="height: 1em; max-height: 1em;" /> . Kiwi is a great tools for making openSUSE liveUSB, QEMU Image, VMWare Image, XEN Image and LiveCD Image but it would not fit with any situation.</p>
<p>I&#8217;ve search various topics and found some of them looks pretty interesting to try. After reviewing some tips, here is a tutorial guide to make openSUSE 11.0 LiveUSB with the easiest way :</p>
<h3><strong><strong>BENEFIT</strong></strong></h3>
<ol>
<li>Tutorial can be used on Linux or Windows</li>
<li>Do not need to install openSUSE onto hard disk for making LiveUSB as it was with KIWI. Just download the LiveCD ISO image and a tools for make an extract of ISO content (7-zip on Windows and mount -o loop tips on Linux)</li>
<li>Can used FAT 32 file system for interoperability (marketing hype <img src="https://s.w.org/images/core/emoji/2.2.1/72x72/1f609.png" alt="&#x1f609;" class="wp-smiley" style="height: 1em; max-height: 1em;" /> ) and mobility of data. Flash disk could be accessing by various OS</li>
<li>Simple, only need a few step</li>
<li>Fast process, required a few minutes for copying ISO image and initrd process</li>
</ol>
<h3><span id="more-38"></span><strong>PREPARATION</strong></h3>
<ol>
<li>Preparing USB Flash Disk, 1 GB or more</li>
<li>If using Windows for making LiveCD, download latest version of <a href="//www.kernel.org/pub/linux/utils/boot/syslinux">syslinux</a></li>
<li>Download modified initrd &#8211; called initrdud &#8211; from <a href="ftp://ftp.emc.com/incoming/suse/">this link</a>. (it&#8217;s free ftp server which deleted any contents every 2 week. You could find another location from <a href="http://www.vavai.com/uploads/opensuse/initrdud">my personal blog uploads folder</a>). The modified initrd contains modification from LiveCD boot into LiveUSB boot and addon for NLS modules (code page and character set) for FAT32 file system on USB. NOTED : for openSUSE 11.0 GM, please used <a href="http://opensuse.or.id/wp-content/uploads/2008/06/initrdud">this initrdud</a> instead. Take a look on <a href="http://lizards.opensuse.org/2008/06/20/how-to-makeopensuse-110-gm-version-live-usb/#more-75">this post</a> for the reason.</li>
</ol>
<h3><strong><strong>MAKE A BOOTABLE LIVEUSB</strong></strong></h3>
<ul>
<li><strong>ON WINDOWS</strong></li>
</ul>
<ol>
<li>Run your Windows OS</li>
<li>Plug in USB Flash Disk</li>
<li>Extract syslinux on Windows folder</li>
<li>Open DOS Prompt (Command Prompt)</li>
<li>Navigate into win32 folder on syslinux folder</li>
<li>run syslinux -ma driver-letter-of-flash-disk, eg : <code>syslinux -ma E: </code> if E is your USB Flash Disk. Note : The process need a few second to make a bootable USB disk with syslinux, so don&#8217;t wait the process finished for 1 minutes or more <img src="https://s.w.org/images/core/emoji/2.2.1/72x72/1f600.png" alt="&#x1f600;" class="wp-smiley" style="height: 1em; max-height: 1em;" /></li>
</ol>
<ul>
<li><strong>ON LINUX</strong>
<ol>
<li>Find your USB disk with <code>df -h</code> on konsole.</li>
<li>Install syslinux and run <strong>syslinux /dev/sdx</strong> from konsole where /dev/sdx is your USB device</li>
<li>If the above process failed for making bootable USB disk, try <a href="http://en.opensuse.org/SuSE_install_from_USB_drive#Make_the_USB_drive_bootable">another tips</a></li>
</ol>
</li>
</ul>
<h3>PROCESSING THE IMAGE</h3>
<ol>
<li>Plug in bootable USB disk</li>
<li>Create temporary folder for mounting LiveCD ISO Image <code>mkdir liveiso</code></li>
<li>Mount ISO image into specified folder <code>mount -o loop openSUSE-11.0-RC1-KDE4-LiveCD-i386.iso liveiso/</code> (I&#8217;m currently using openSUSE 11.0 RC1 KDE. Make a proper changes to your ISO image)</li>
<li>Copying all of liveiso content (mounted ISO content) into USB disk</li>
<li>Copying all of content on boot/i386/loader folder into root folder of USB disk</li>
<li>Rename isolinux.cfg on root folder of USB disk into syslinux.cfg</li>
<li>copying initrdud into root folder of usb disk</li>
<li>Make a few modification into syslinux.cfg, so, USB live will boot with initrdud. Make a change to this line : <code>append initrd=initrd ramdisk_size=512000 ramdisk_blocksize=4096 splash=silent showopts</code> into <code>append initrd=initrdud kiwidebug=1 ramdisk_size=512000 ramdisk_blocksize=4096 splash=silent showopts</code> kiwidebug=1 option will log any error while booting LiveUSB</li>
</ol>
<h3>TESTING</h3>
<ol>
<li>Boot your computer with USB HDD as top of boot device priority or make a hot boot change by pressing F12, F8, F9 or any key according to your computer</li>
<li>While booting, just press ENTER on boot option. Typing Live-System as mentioned on boot message will failed <img src="https://s.w.org/images/core/emoji/2.2.1/72x72/1f642.png" alt="&#x1f642;" class="wp-smiley" style="height: 1em; max-height: 1em;" /> regarding kernel image</li>
</ol>
<p><a href="http://www.vavai.com/blog/uploads/liveusb-1.png"><img src="http://www.vavai.com/blog/uploads/liveusb-2.jpg" alt="LiveUSB Sysinfo" width="500" height="333" /></a></p>
<h3>LIVEUSB INSTALLATION SCREENSHOT</h3>
<p>Below are some LiveUSB installation screenshot.</p>
<p><a href="http://www.vavai.com/blog/uploads/liveusb-3.png"><img src="http://www.vavai.com/blog/uploads/liveusb-3.jpg" alt="LiveUSB Installation Screen" width="500" height="371" /></a></p>
<p><a href="http://www.vavai.com/blog/uploads/liveusb-4.png"><img src="http://www.vavai.com/blog/uploads/liveusb-4.jpg" alt="LiveUSB Installation Screen" width="500" height="371" /></a></p>
<p><a href="http://www.vavai.com/blog/uploads/liveusb-5.png"><img src="http://www.vavai.com/blog/uploads/liveusb-5.jpg" alt="LiveUSB Installation Screen" /></a></p>
<h3>CREDIT</h3>
<p>Thanks to <a href="http://www.suseforums.net/index.php?s=d7a69cd0371561b0907600e2757d5ab9&amp;showuser=47359">Manivas</a> for <a href="http://suseforums.net/index.php?showtopic=50712">great idea &amp; tutorial</a>.</p>
<h3>FUTURE IDEA</h3>
<p><a href="http://en.opensuse.org/User:Coolo">Coolo</a> was <a href="http://lists.opensuse.org/opensuse-factory/2008-05/msg00455.html">discarded his experimental test</a> for making openSUSE liveUSB. The above process should be fine and *I think* quite enough to provide openSUSE LiveUSB for 11.0 released. By automating overall process and making a nice GUI, it should be increasing openSUSE 11.0 features. (if you asked me, &#8220;Why don&#8217;t you create automated process tools by yourself&#8221;, my answer is : &#8220;Yes, I will. I just thinking that it may need a less than a day for experience openSUSE developers for making the tools rather than waiting my C++ &amp; QT course finished <img src="https://s.w.org/images/core/emoji/2.2.1/72x72/1f600.png" alt="&#x1f600;" class="wp-smiley" style="height: 1em; max-height: 1em;" /> )</p>
<p>In 10.3, it was need a month after official release of 10.3 on October 04, 2008 for releasing LiveCD version of openSUSE. With this experience, is this possible to make this features included on openSUSE 11.0 ?</p>
]]></content:encoded>
			<wfw:commentRss>https://lizards.opensuse.org/2008/05/31/making-opensuse-110-liveusb-the-easiest-and-fastest-way/feed/</wfw:commentRss>
		<slash:comments>35</slash:comments>
		</item>
	</channel>
</rss>
